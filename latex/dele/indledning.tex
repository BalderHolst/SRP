\chapter*{Indledning}
\label{ch:Indledning}
\addcontentsline{toc}{chapter}{\nameref{ch:Indledning}}

Alt sorteres. Navne, bøger, lande, slik, biler, ALT. Hver gang vi søger på Google, sorteres søgeresultaterne efter relevans, og når vi scroller på Tiktok eller Facebook, er opslagene sorteret på baggrund af tidspunktet, de er postet og den personlige data, der står i deres databaser.\\

Sortering er en måde at ordne data, så de er nemme at finde igen. Servere verden rundt bruger store dele af deres ydeevne på netop at sortere de data, som de lagrer. Optimering af sorteringsalgoritmer er derfor essentiel for det moderne samfunds gigantiske dataafhængighed, da de drastisk kan nedsætte databehandlingens udførelsestid.\\

Denne opgave omhandler sorteringsalgoritmer og analysen af dem ved hjælp af store-O og kompleksitets-klasser. Først defineres store-O, og herefter tages der udgangspunkt i sorteringsalgoritmerne insertionsort og mergesort, hvis tidskompleksitet diskuteres og bevises. Blandt andet vises det, at insertionsort har en værste-tilfælde-vækstrate på $O(n^2)$. Binære træer bruges i afsnittet efter, til at bevise at den nedre grænse for værste-tilfælde-vækstraten er $O(n \cdot \log n)$ for alle sorteringsalgoritmer. Det vil også blive forklaret hvorfor, insertionsort med en bedste-tilfælde-vækstrate på $O(n)$ ikke overskrider denne grænse. Til sidst implementeres algoritmerne i Python og deres reelle køretider undersøges. Algoritmerne samles til en hybrid-algoritme, der sammenlignes med mergesort.
