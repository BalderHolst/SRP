\chapter*{Indledning}
\label{ch:Indledning}
\addcontentsline{toc}{chapter}{\nameref{ch:Indledning}}

Alt sorteres. Navne, bøger, lande, slik, biler, ALT. Hver gang vi søger på Google, sorteres søgeresultaterne efter relevans, og når vi scroler på Tiktok eller Facebook, er opslagene sorteret, på baggrund af tidspunktet de er postet, og den personlige data der står i deres databaser.\\

Sortering er en måde at ordne data, så de er nemme at finde igen. Servere verden rundt bruger store dele af deres ydeevne på netop, at sortere den data de lagre. Optimering af disse algoritmer er derfor essentiel for det moderne samfunds gigantiske dataafhængighed, da de drastisk kan nedsætte databehandlings udførelsestid.\\

Denne opgave omhandler sorteringsalgoritmer, og analysen af dem ved hjælp af store-O og kompleksitsklasser. Først defineres store-O, og herefter tages der udgangspunkt i sorteringsalgoritmerne insertionsort og mergesort, hvis tidskompleksitet diskuteres og bevises. Blandt andet vises det at insertionsort har en værste-tilfælde-vækstrate på $O(n^2)$. Binære træer bruges i afsnittet efter, til at bevise at den nedregrænse for værste-tilfælde-vækstraten er $O(n \cdot \log n)$. Det vil også forklares hvorfor det, at insertionsort har en bedste-tilfælde-vækstrate på $O(n)$, ikke overskrider denne grænse. Til sidst implementeres algoritmerne i Python og deres reelle køretider undersøges. Algoritmerne samles til en hybridalgoritme, er sammenlignes med mergesort.
