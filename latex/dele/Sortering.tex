\chapter{Sorteringsalgoritmer}
\label{ch:Sorteringsalgoritmer}

\section{Hvad er sortering?}
\label{sec:Hvad er sortering?}

\begin{figure}
	\begin{center}
		$$[4,2,5,3,1] \:\:\longrightarrow\:\: [1,2,3,4,5]$$
	\end{center}
	\caption{Eksempel på sortering af en liste}
	\label{fig:Eksempel på sortering af en liste}
\end{figure}


Sortering er helt lavpraktisk at sætte en mængde data en rækkefølge på baggrund af dataens attributter. Det kunne f.eks. være alfabetisk eller efter farve eller størrelse. Det er dog ikke entydigt hvilken sorterings-strategi der ville være hurtigst. Disse sorterings-strategier kan også kaldes sorterings-algoritmer, det er ikke kun mennesker der kan benytte sorterings-algoritmer til f.eks. at sortere kort, men computere kan også, og de gør det for det meste også hurtigere. De næste to afsnit omhandler to forskellige sorterings-algoritmer, og deres måde at sortere en liste med tal.\\


Herfra vil jeg kun forholde mig til sortering af lister med tal, og sortere dem på baggrund af deres størrelse (se figur \ref{fig:Eksempel på sortering af en liste})


\section{Insertionsort}
\label{sec:Insertionsort}

Insertionsort er en af de mere simple sorteringsalgoritmer. Pseudokoden til algoritmen kan ses i figur \ref{fig:Pseudokode til insertionsort}


Det er ikke en tilfældighed at denne algoritme hedder insertionsort. Den fungerer nemlig ved at gennemgå gennemgå hvert element i listen, og placere det hvor det passer ind i de elementer der allerede er sorterede. Dette er nok til dels den måde man f.eks. ville sortere sin hånd i Uno eller 500. 

\subsection{Insertionsort Procedure}%
\label{sub:Insertionsort Procedure}

At algoritmen gennemgår alle elementerne i listen kronologisk kan vi se allerede i linje 2, da algoritmen her begynder med en for-lykke, der tæller for hvert element i listen, dog starter den ved 2. element i listen. For at gøre koden mere læsbar sættes elementet som algoritmen er nået til ind i variablen e i linje 3. Det næste algoritmen gør, er at checke om elementet har en mindre værdi end det første element i listen, hvis dette er sandt rykkes alt før elementet et tak til højre, og elementet sættes ind først i listen (se figur \ref{fig:Indsæt element først i listen}).

\begin{figure}[h]
	\begin{center}
		\padtable
		\begin{tabular}{l|c|c}
			Forklaring & Eksempel & Linje \\
			\hline
			Liste hvor \verb|e < liste[0]| & $[\blue{5},\blue{7},\blue{9},\red{4},6,5,2]$ & $5$ \\
			Rykker til venstre & $[\blue{5},\blue{5},\blue{7},\blue{9},6,5,2]$ & $6$-$8$\\
			Sætter elementet ind først  & $[\red{4},\blue{5},\blue{7},\blue{9},6,5,2]$ & $9$
		\end{tabular}
	\end{center}
	\vspace{-3mm}
	\caption{Procedure for at indsætte element først i listen. Elementet er markeret med \red{rød}, og tal der på allerede er sorterede er markeret med \blue{blå}. Linjer refererer til koden i figur \ref{fig:Pseudokode til insertionsort}.}
	\label{fig:Indsæt element først i listen}
\end{figure}


Vi er nu nået til linje $11$. Hvis ikke elementet er mindre end det første element i listen sker følgende (se figur \ref{fig:Indsæt element hvor det passer i listen}): Algoritmen ser på tallet før elementet og spørger: "er dette tal større end elementet". Hvis det er, rykkes det hen på elementets plads. Herefter stiller algoritmen samme spørgsmål, til tallet to pladser før elementet. Hvis dette tal er mindre and elementet placerer algoritmen elementet efter dette tal, hvis ikke stiller den samme spørgsmål til tallet 3 pladser før elementet og så videre. Det er vigtigt at pointere, at der altid vil være et tal der er mindre end elementet, da elementet ellers ville være blevet placeret først i liste af den første del af algoritmenen (linje $5$-$10$).


\begin{figure}[h]
	\begin{center}
		\padtable
		\begin{tabular}{l|c|c}
			Forklaring & Eksempel & Linje\\
			\hline
			Liste hvor \verb|e >= liste[0]| & $[\blue{4},\blue{5},\blue{7},\blue{9},\red{6},5,2]$ &$11$\\
			Da $9 \geq 6$ rykkes tallet til højre & $[\blue{4},\blue{5},\blue{7},\blue{9},\blue{9},5,2]$ & $13$-$14$\\
			Da $7 \geq 6$ rykkes tallet til højre & $[\blue{4},\blue{5},\blue{7},\blue{7},\blue{9},5,2]$ & $13$-$14$\\
			Da $5 \ngeq 6$ sættes elementet ind efter $5$ & $[\blue{4},\blue{5},\red{6},\blue{7},\blue{9},5,2]$ & $13$ og $17$
		\end{tabular}
	\end{center}
	\vspace{-3mm}
	\caption{Procedure for at indsætte et element hvor det passer i den sorterede liste. Elementet er markeret med \red{rød}, og tal der på allerede er sorterede er markeret med \blue{blå}. Linjer refererer til figur \ref{fig:Pseudokode til insertionsort}.}
	\label{fig:Indsæt element hvor det passer i listen}
\end{figure}

\begin{figure}[h]
	\begin{center}
		\begin{lstlisting}
		funktion insertionsort(liste) {
			for i = 1 til i = n {					# her er n længden af listen
			e = liste[i]	 							# dette er elementet i listen

				if e < liste[0] {						# hvis elementet er større end det første element i listen
					for j = j til j = 0{ 
						liste[j] = liste[j-1]		# ryk elementerne på pladserne 0 til j et tak frem
					}
				liste[0] = e 							# sætter dette element forrest i listen
				}
				else{
					j = i 								# j er en nu tæller der starter på i
					while liste[j-1] > e {			# kør mens liste[j-1] er størren end elementet
						liste[j] = liste[j-1] 		# ryk liste[j] et tak til højre
						j -= 1
					}
					liste[j] = element				# indsæt elementet hvor det passer ind
				}
			}			
			return(liste)								# returnerer den sorterede liste
		}
		\end{lstlisting}
	\end{center}
	\vspace{-5mm}
	\caption{Pseudokode til insertionsort \cite[s. 104]{aogd}.}
	\label{fig:Pseudokode til insertionsort}
\end{figure}



\subsection{Egenskaber af Insertionsort}%
\label{sub:Egenskaber af Insertionsort}
Insertionsort er en god sorteringsalgoritme, idet at proceduren er forholdsvis nem at forstå, men også at listen til venstre for det element algoritmen er nået til, altid vil være sorteret. Hvis man stopper en insertionsort-algoritme halvvejs gennem dens køretid, vil man altid have en liste hvor den første halvdel er sorteret og den anden halvdel usorteret. Dette er ikke en egenskal i den næste algoritme.\\

(se afsnit \ref{sec:Analyse af Insertionsort} for store-O analysen)



\section{Mergesort}
\label{sec:Mergesort}

Hvor insertionsort er en lykke-baseret algoritme, er mergesort rekursiv idet at den ikke benytter en lykke til at gentage instruktioner, men kalder sig selv i stedet. Dette leder til en fraktallignende sorteringsmetode, der deler problemet i mindre og mindre bidder. 

\subsection{Mergesort Procedure}%
\label{sub:Mergesort Procedure}

Pseudokode til denne algoritme kan findes i figur \ref{fig:Pseudokode til mergesort}.\\

Mergesortalgoritmen består af to funktioner. Lad os begynde med funktionen $merge$, da det er den mest simple. Funktionen tager to lister ($a$ og $b$) som argumenter, og fletter dem sammen til en tredje liste ($c$). Denne $c$ liste er delvist sorteret, og består af flere små sorterede dele. Eksempelvis kunne dette være en returneret liste:

$$merge([1,2,4,8],[9,5,6,4,7]) \longrightarrow [\orange{1}, \orange{2}, \orange{4}, \orange{8}, \orange{9}, \blue{5}, \blue{6}, \violet{4}, \violet{7}]$$



En vigtig egenskab af $merge$ er at, den kan flette to sorterede lister sammen, til én samlet liste. Det kunne for eksempel være i dette tilfælde:


$$merge([1,3,4,8],[2,3,6,7,7]) \longrightarrow [1, 2, 3, 3, 4, 6, 7, 7, 8]$$



\begin{figure}
	\begin{center}
		\padtable
		\begin{tabular}{l|c|c|c|c}
			Forklaring & $a$ & $b$ & $c$ & Linje\\
			\hline
			 Da $a[0] \leq b[0]$ føjes $a[0]$ til $c$ & $[\red{4},6,1]$ & $[\red{5},3,7,5]$ & [\:] & $18$-$21$\\
			 Da $a[0] \nleq b[0]$ føjes $b[0]$ til $c$ & $[\red{6},1]$ & $[\red{5},3,7,5]$ & $[\violet{4}]$ & $22$-$25$\\
			 Da $a[0] \nleq b[0]$ føjes $b[0]$ til $c$ & $[\red{6},1]$ & $[\red{3},7,5]$ & $[\blue{4},\violet{5}]$ & $22$-$25$\\
			 Da $a[0] \leq b[0]$ føjes $a[0]$ til $c$ & $[\red{6},1]$ & $[\red{7},5]$ & $[\blue{4},\blue{5},\violet{3}]$ & $18$-$21$\\
			 Da $a[0] \leq b[0]$ føjes $a[0]$ til $c$ & $[\red{1}]$ & $[\red{7},5]$ & $[\blue{4},\blue{5},\blue{3},\violet{6}]$ & $18$-$21$\\
			 Da $a.length = 0$ føjes $b$ til $c$ & $\red{[\:]}$ & $[7,5]$ & $[\blue{4},\blue{5},\blue{3},\blue{6},\violet{1}]$ & $12$-$14$\\
			 Returnerer $c$ & $[\:]$ & $[\:]$ & $[\blue{4},\blue{5},\blue{3},\blue{6},\blue{1},\violet{7},\violet{5}]$ & $13$\\
		\end{tabular}
	\end{center}
	\caption{Eksempel med delfunktionen \emph{merge} i mergesort. Her kalder vi merge($[4,6,1]$, $[5,3,7,5]$). I hvert trin sammenlignes de \red{røde } tal. \blue{Blå }tal er en del af den færdige $c$ liste, og \violet{lilla } tal er de tal der sidst blev føjet til $c$. Linjer refererer til figur \ref{fig:Pseudokode til mergesort}.}
	\label{fig:merge i mergesort}
\end{figure}



\begin{figure}
	\begin{center}
		\begin{lstlisting}
			funktion mergesort(liste) {
				if liste.length == 1{
					return(liste)
				}
				else {
					return(merge(mergesort(liste[0 ... n/2]), mergesort(liste[n/2 + 1 ... n])))
				}
			}

			funktion merge(a,b) {
				c = []

				while(true) {
					if a.length == 0 {
						return(c + b)
					}
					elif b.length == 0 {
						return(c + a)
					}
					elif a[0] <= b[0] {
						tilføj a[0] til c
						fjern a[0] fra a
					}
					else {
						tilføj b[0] til c
						fjern b[0] fra b
					}
				}
			}

		\end{lstlisting}
	\end{center}
	\vspace{-5mm}
	\caption{Pseudokode til Mergesort \cite[s. 106]{aogd}.}
	\label{fig:Pseudokode til mergesort}
\end{figure}


\section{Analyse af Insertionsort}
\label{sec:Analyse af Insertionsort}


